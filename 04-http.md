[<< Обработчик ошибок](03-error-handler.md) | [Маршрутизатор >>](05-router.md)

### HTTP

Из под коробки PHP предоставляет некоторые средства для работы с HTTP. К примеру [суперглобальные переменные](http://php.net/manual/ru/language.variables.superglobals.php) содержат информацию запроса.

Они хороши, если вы разрабатываете небольшой скрипт. Однако, если мы хотим написать чистый, поддерживаемый, [SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) код, тогда нам понадобится класс с хорошим объектно-ориентированным интерфейсом.

И опять же, мы не будем изобретать велосипед, а просто установим сторонний модуль для работы с HTTP. Я решил написать свой собственный [HTTP компонент](https://github.com/PatrickLouys/http), так как меня не устраивают существующие, но вам не обязательно делать то же что и я :)

Альтернативами могу послужить: [Symfony HttpFoundation](https://github.com/symfony/HttpFoundation), [Nette HTTP Component](https://github.com/nette/http), [Aura Web](https://github.com/auraphp/Aura.Web), [sabre/http](https://github.com/fruux/sabre-http)

В данном туториале я буду использовать компонент написаный мною, но вы можете использовать любой другой который вам нравится.

Давайте добавим нужный нам пакет в `composer.json` и запустим команду `composer update`:

```json
  "require": {
    "php": ">=7.0.0",
    "filp/whoops": "~2.1",
    "patricklouys/http": "~1.4"
  },
```

Теперь мы можем добавить данный код после регистрации обработчика ошибок в `Bootstrap.php` (и не забудте удалить исключение, которое мы добавляли в прошлом уроке).

```php
$request = new \Http\HttpRequest($_GET, $_POST, $_COOKIE, $_FILES, $_SERVER);
$response = new \Http\HttpResponse;
```
Мы создали обьекты запроса `Request` и ответа `Response`, которые можем использовать в других классах для получения данных запроса и отправки ответа назад в браузер.

Чтобы отправить что-то обратно в браузер нам нужно добавить следующий кусок кода в конец файла `Bootstrap.php`:

```php
foreach ($response->getHeaders() as $header) {
    header($header, false);
}

echo $response->getContent();
```

Если мы этого не сделаем, то ничего не произойдет, поскольку объект «Response» только хранит данные.

Второй параметр метода `header()` устанавливаем false чтобы избежать перезаписи существующих заголовков ответа.

Сейчас наш код отправляет пустой ответ браузеру со статусом `200`; Давайте изменим это, вставив следующий код в `Bootstrap.php` (выше инструкции `foreach`)

```php
$content = '<h1>Hello World</h1>';
$response->setContent($content);
```

Если мы хотим вернуть 404:

```php
$response->setContent('404 - Page not found');
$response->setStatusCode(404);
```
Помните что обьект ответа только хранит данные, и если вы установите статус код множество раз перед отправкой ответа, приложение вернет тот который был установлен последним.

[<< Обработчик ошибок](03-error-handler.md) | [Маршрутизатор >>](05-router.md)
