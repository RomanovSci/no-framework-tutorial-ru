[<< Контроллер](06-controller.md) | [Внедрение зависимостей >>](08-dependency-injector.md)

### Инверсия управления

В предыдущей части мы настрояли контроллер и вывели информацию в окно браузер с помощью команды `echo`. Но давайте не забывать о том что у нас имеется хорошая, объектно-ориентировання абстракция для работы с HTTP. К сожалению, на данный момент, мы не имеем доступ к классам ответа и запроса из нашего контроллера.

Хорошей практикой является использование [инверсия управления](http://en.wikipedia.org/wiki/Inversion_of_control). Это означает, что вместо того, чтобы возлагать обязаности по созданию объектов на класс, мы просто запрашиваем нужные нам объекты из текущего класса. Данный подход реализуется с помощью [внедрения зависимостей](http://en.wikipedia.org/wiki/Dependency_injection).

Не беспокойтесь если сейчас это звучит немного сложно. Просто следуйте руководству и вы убедитесь в том, что данный подход действительно прост в реализации.

Давайте немного изменим наш `Homepage` контроллер:

```php
<?php declare(strict_types = 1);

namespace Example\Controllers;

use Http\Response;

class Homepage
{
    private $response;

    public function __construct(Response $response)
    {
        $this->response = $response;
    }

    public function show()
    {
        $this->response->setContent('Hello World');
    }
}
```

Обратите внимание, что мы [импортируем](http://php.net/manual/en/language.namespaces.importing.php) `Http\Response` в верхней части файла. Это означает, что всякий раз, когда вы используете имя `Response` внутри данного файла, PHP подставляет полное имя данного класса.

Мы явно указываем тип передаваемого в конструктор аргумента как `Http\Response`. В данном случае, `Http\Response` является интерфейсом, а значит любой класс который реализует данный интерфейс может быть внедрен в наш контроллер. Более подробно об [объявлении типов](http://fi2.php.net/manual/ru/functions.arguments.php#functions.arguments.type-declaration) и [интерфейсах](http://fi2.php.net/manual/ru/language.oop5.interfaces.php).

По скольку мы еще ничего не внедрили, наш код будет выдавать ошибку. Давайте исправим ситуацию. В файле `Bootstrap.php` при создании экзепляра класса контроллера, передадим конструктору объект ответа:

```php
$class = new $className($response);
$class->$method($vars);
```
Класс `Http\HttpResponse` имплементирует`Http\Response` интерфейс, а значит мы можем использовать его в нашем контроллере.

Сейчас код должен работать как прежде. Но если оставить так как есть, все ваши контроллеры будут использовать один и тот же объект ответа, что не есть хорошо. Давайте исправим эту проблему в следующем разделе

[<< Контроллер](06-controller.md) | [Внедрение зависимостей >>](08-dependency-injector.md)
