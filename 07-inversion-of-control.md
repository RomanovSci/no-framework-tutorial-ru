[<< Контроллер](06-controller.md) | [Инъектор зависимостей >>](08-dependency-injector.md)

### Инверсия управления

В предыдущей части мы настрояли контроллер и вывели информацию в окно браузер с помощью команды `echo`. Но давайте не забывать о том что у нас имеется хорошая, объектно-ориентировання абстракция для работы с HTTP. К сожалению, сейчас, у нас нету доступа к классам ответа и запроса из нашего контроллера.

Хорошей практикой является использование [инверсия управления](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F). Это означает, что вместо того, чтобы возлагать обязаности по созданию объектов на класс, мы просто запрашиваем нужные нам объекты из контейнера. Данный подход реализуется с помощью [внедрения зависимостей](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8). Не беспокойтесь если сейчас это звучит как-то сложно. Просто следуйте руководству и вы убедитесь в том, что данный подход действительно прост в реализации.

Давайте немного изменим наш `Homepage` контроллер:

```php
<?php declare(strict_types = 1);

namespace Example\Controllers;

use Http\Response;

class Homepage
{
    private $response;

    public function __construct(Response $response)
    {
        $this->response = $response;
    }

    public function show()
    {
        $this->response->setContent('Hello World');
    }
}
```

Обратите внимание, что мы [импортируем](http://php.net/manual/ru/language.namespaces.importing.php) `Http\Response` в верхней части файла. Это означает, что всякий раз, когда вы используете имя `Response` внутри данного файла, PHP подставляет полное имя этого класса.

Мы явно указываем тип передаваемого в конструктор аргумента как `Http\Response`. В данном случае, `Http\Response` является интерфейсом, а значит любой класс который реализовывает данный интерфейс может быть внедрен в наш контроллер. Более подробно об [объявлении типов](http://fi2.php.net/manual/ru/functions.arguments.php#functions.arguments.type-declaration) и [интерфейсах](http://fi2.php.net/manual/ru/language.oop5.interfaces.php).

Поскольку мы еще ничего не внедрили, наш код будет генерировать ошибку. Давайте это исправим. В файле `Bootstrap.php` при создании экземпляра контроллера, передадим объект ответа в аргумент конструктора:

```php
$class = new $className($response);
$class->$method($vars);
```
Класс `Http\HttpResponse` имплементирует`Http\Response` интерфейс, а значит мы можем использовать его в данном контроллере. Сейчас код должен работать как прежде. Но если оставить все как есть, то абсолютно все контроллеры будут принимать одни и теже объекты. Давайте исправим эту проблему в следующем разделе.

[<< Контроллер](06-controller.md) | [Инъектор зависимостей >>](08-dependency-injector.md)
